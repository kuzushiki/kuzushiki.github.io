<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
		<title>nullcon HackIM2020 write up &middot; kuzushikiのぺーじ</title>
		<link rel="canonical" href="https://kuzushiki.github.io/post/nullconhackim2020/">
		<link rel="stylesheet" type="text/css" href="https://kuzushiki.github.io/css/main.css" />
		
	</head>
	<body>
		<a id="title" href="https://kuzushiki.github.io/" title="kuzushikiのぺーじ">
			
				<img id="logo" alt="Logo" src="https://kuzushiki.github.io/images/logo.png" />
			
			
				<h1>kuzushikiのぺーじ</h1>
			
		</a>
		
			<h4>セキュリティに関することを書きたいですね</h4>
		
		<div id="social">
			
			
			
			<a href="https://github.com/kuzushiki" title="Github">
				<img alt="GitHub" height="64px" width="64px" src="https://kuzushiki.github.io/images/github.svg" />
			</a>
			
			
			
			<a href="https://twitter.com/kuzu7shiki" title="Twitter">
				<img alt="Twitter" height="64px" width="64px" src="https://kuzushiki.github.io/images/twitter.svg" />
			</a>
			
			
                        
		</div>
		<div class="links">
			<a href="https://kuzushiki.github.io/">Home</a>
			
				<a href="https://kuzushiki.github.io/post/">Archive</a>
			
			
				
			
				
					<a href="https://kuzushiki.github.io/pages/resume/">Résumé</a>
				
			
		</div>

	<div class="postBody">
		<div class="post">
			<h1>nullcon HackIM2020 write up</h1>
			<span class="post-meta">Sat, Feb 15, 2020 - Read in 6 Min</span>
			<div class="content">
			<nav id="TableOfContents">
  <ul>
    <li><a href="#rockpaperscissors">RockPaperScissors</a></li>
    <li><a href="#zelda1">Zelda1</a></li>
    <li><a href="#zelda2">Zelda2</a></li>
    <li><a href="#zelda3">Zelda3</a></li>
    <li><a href="#感想">感想</a></li>
  </ul>
</nav>
			<h1 id="nullcon-hackim-2020-に参加しました"><strong>nullcon HackIM 2020</strong> に参加しました！</h1>
<p>(team: team_Yamasan)</p>
<p>某CTFをやってみよう会にて参加しました。</p>
<p>普段は一人参加だったので、チームでやるのが新鮮で面白かったです。</p>
<p>合計476点を獲得し、最終結果は119位でした。</p>
<p>以下解けた問題のwrite up</p>
<h2 id="rockpaperscissors">RockPaperScissors</h2>
<p>じゃんけんをして20連勝すればいい</p>
<p>3^20分の1を当てるのはスマートでは無い</p>
<p>相手はコミットメントを生成し、勝負の前に表示してくれるので、コミットメントから出す手を推測できれば勝ちである</p>
<p>コミットメントは以下のように作られる（AESっぽい感じ）</p>
<pre><code>sbox = [221, 229, 120, 8, 119, 143, 33, 79, 22, 93, 239, 118, 130, 12, 63, 207, 90, 240, 199, 20, 181, 4, 139, 98, 78, 32, 94, 108, 100, 223, 1, 173, 220, 238, 217, 152, 62, 121, 117, 132, 2, 55, 125, 6, 34, 201, 254, 0, 228, 48, 250, 193, 147, 248, 89, 127, 174, 210, 57, 38, 216, 225, 43, 15, 142, 66, 70, 177, 237, 169, 67, 192, 30, 236, 131, 158, 136, 159, 9, 148, 103, 179, 141, 11, 46, 234, 36, 18, 191, 52, 231, 23, 88, 145, 101, 17, 74, 44, 122, 75, 235, 175, 54, 40, 27, 109, 73, 202, 129, 215, 83, 186, 7, 163, 29, 115, 243, 13, 105, 184, 68, 124, 189, 39, 140, 138, 165, 219, 161, 150, 59, 233, 208, 226, 176, 144, 113, 146, 19, 224, 111, 126, 222, 178, 47, 252, 99, 87, 134, 249, 69, 198, 164, 203, 194, 170, 26, 137, 204, 157, 180, 168, 162, 56, 81, 253, 213, 45, 21, 58, 24, 171, 37, 82, 53, 50, 84, 196, 232, 242, 244, 64, 80, 10, 114, 212, 187, 205, 28, 51, 182, 16, 107, 245, 211, 85, 92, 195, 5, 197, 200, 31, 183, 61, 123, 86, 167, 154, 41, 151, 35, 247, 246, 153, 95, 206, 149, 76, 112, 71, 230, 106, 188, 172, 241, 72, 156, 49, 14, 214, 155, 110, 102, 116, 128, 160, 135, 104, 77, 91, 190, 60, 42, 185, 96, 97, 251, 218, 133, 209, 65, 227, 3, 166, 255, 25]
p = [5, 9, 1, 8, 3, 11, 0, 12, 7, 4, 14, 13, 10, 15, 6, 2]
round = 16

def gen_commitments():
    secret = bytearray(Random.get_random_bytes(16))
    rc = hash(secret + b&quot;r&quot;)
    pc = hash(secret + b&quot;p&quot;)
    sc = hash(secret + b&quot;s&quot;)
    secret = hex(bytes_to_int(secret))[2:]
    rps = [(&quot;r&quot;, rc), (&quot;p&quot;, pc), (&quot;s&quot;, sc)]
    print(rps)
    random.shuffle(rps)
    return secret, rps

def hash(data):
    state = bytearray([208, 151, 71, 15, 101, 206, 50, 225, 223, 14, 14, 106, 22, 40, 20, 2])
    data = pad(data, 16)
    print(data)
    data = group(data)
    print(data)
    for roundkey in data:
        print(&quot;roundkey&quot;, roundkey)
        for _ in range(round):
            state = repeated_xor(state, roundkey)
            for i in range(len(state)):
                state[i] = sbox[state[i]]
            temp = bytearray(16)
            for i in range(len(state)):
                temp[p[i]] = state[i]
            state = temp
        print(&quot;state&quot;, state)
    return hex(bytes_to_int(state))[2:]
</code></pre><p>概要をざっくり説明すると、<code>gen_commitments</code>では<code>secret</code>をまず生成し、それにそれぞれの手を足したものを<code>hash</code>に投げている</p>
<p><code>hash</code>では入力をパディングし、分割し、パーツごとにXOR, 置換などのAESっぽい処理をする</p>
<p>例えばパーの場合は<code>b'/\xdcF\xcd1x\xa9\x02%\x12\xba\x81\x17\xff$^</code>と
<code>b'p\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f'</code>に分けられる</p>
<p>2つ目のパーツの先頭1バイトが<code>p,r,c</code>のいずれかになることを利用する</p>
<p><code>hash</code>には乱数を使った処理が無いので、逆算が可能である</p>
<p>得られるコミットメントにたいして<code>hash</code>と逆の処理を施してあげれば、元の入力を求められるはずである</p>
<p>以下のような関数を作る</p>
<pre><code>def dec_hash(old_state_list):
    roundkey_list = [bytearray(b'r\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f'),
        bytearray(b'p\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f'),
        bytearray(b's\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f')
        ]

    total_state_list = []
    for old_state in old_state_list:
        new_state_list = []
        for roundkey in roundkey_list:
            state = int_to_bytes(old_state)
            temp = [0] * len(state)
            for i in range(len(state)):
                temp[i]  = state[p[i]]
            for i in range(len(state)):
                temp[i] = sbox.index(temp[i])
            new_state = repeated_xor(temp, roundkey)
            new_state_list.append(new_state[0])
        total_state_list.append(new_state_list)
    return total_state_list
</code></pre><p>復号結果は以下のようになる</p>
<pre><code>[
    [bytearray(b'#\xb6\xcb\xa6\x850!\xedr\x15\x1c&gt;\x89\xe7Ch'), 
    bytearray(b'!\xb6\xcb\xa6\x850!\xedr\x15\x1c&gt;\x89\xe7Ch'), 
    bytearray(b'&quot;\xb6\xcb\xa6\x850!\xedr\x15\x1c&gt;\x89\xe7Ch')],

    [bytearray(b' W\x05\xa4\xdc\xfa\xdf\xe6\x90dJM\xb2\x10Et'), 
    bytearray(b'&quot;W\x05\xa4\xdc\xfa\xdf\xe6\x90dJM\xb2\x10Et'), 
    bytearray(b'!W\x05\xa4\xdc\xfa\xdf\xe6\x90dJM\xb2\x10Et')], 

    [bytearray(b'&quot;8\xa1\x9f\n\xe4\xbfu\xf26\xd7\xdd\xf6\x816\xf0'), 
    bytearray(b' 8\xa1\x9f\n\xe4\xbfu\xf26\xd7\xdd\xf6\x816\xf0'), 
    bytearray(b'#8\xa1\x9f\n\xe4\xbfu\xf26\xd7\xdd\xf6\x816\xf0')]]
</code></pre><p>３つのコミットメントを<code>r,p,c</code>のそれぞれで復号してみたもの</p>
<p>すると復号結果の1バイト目が一致することが分かる（上の例では<code>b'&quot;'</code>）</p>
<p>これが一致しているものが正解である</p>
<p>上の例では上からチョキ、グー、パーとなる</p>
<p>（なぜ1バイト目しか一致しないのかは分かりませんでした）</p>
<p>後はコミットメントを読み取り、復号し、出す手を決めて送るプログラムをつくる</p>
<pre><code>from pwn import *
import time

from Crypto import Random
from Crypto.Random import random
from Crypto.Util.number import *

sbox = [221, 229, 120, 8, 119, 143, 33, 79, 22, 93, 239, 118, 130, 12, 63, 207, 90, 240, 199, 20, 181, 4, 139, 98, 78, 32, 94, 108, 100, 223, 1, 173, 220, 238, 217, 152, 62, 121, 117, 132, 2, 55, 125, 6, 34, 201, 254, 0, 228, 48, 250, 193, 147, 248, 89, 127, 174, 210, 57, 38, 216, 225, 43, 15, 142, 66, 70, 177, 237, 169, 67, 192, 30, 236, 131, 158, 136, 159, 9, 148, 103, 179, 141, 11, 46, 234, 36, 18, 191, 52, 231, 23, 88, 145, 101, 17, 74, 44, 122, 75, 235, 175, 54, 40, 27, 109, 73, 202, 129, 215, 83, 186, 7, 163, 29, 115, 243, 13, 105, 184, 68, 124, 189, 39, 140, 138, 165, 219, 161, 150, 59, 233, 208, 226, 176, 144, 113, 146, 19, 224, 111, 126, 222, 178, 47, 252, 99, 87, 134, 249, 69, 198, 164, 203, 194, 170, 26, 137, 204, 157, 180, 168, 162, 56, 81, 253, 213, 45, 21, 58, 24, 171, 37, 82, 53, 50, 84, 196, 232, 242, 244, 64, 80, 10, 114, 212, 187, 205, 28, 51, 182, 16, 107, 245, 211, 85, 92, 195, 5, 197, 200, 31, 183, 61, 123, 86, 167, 154, 41, 151, 35, 247, 246, 153, 95, 206, 149, 76, 112, 71, 230, 106, 188, 172, 241, 72, 156, 49, 14, 214, 155, 110, 102, 116, 128, 160, 135, 104, 77, 91, 190, 60, 42, 185, 96, 97, 251, 218, 133, 209, 65, 227, 3, 166, 255, 25]
p = [5, 9, 1, 8, 3, 11, 0, 12, 7, 4, 14, 13, 10, 15, 6, 2]
round = 16


def pad(data, size = 16):
    pad_byte = (size - len(data) % size) % size
    data = data + bytearray([pad_byte]) * pad_byte
    return data


def repeated_xor(p, k):
    return bytearray([p[i] ^ k[i % len(k)] for i in range(len(p))])


def bytes_to_int(xbytes):
    return bytes_to_long(xbytes)


def int_to_bytes(x):
    return long_to_bytes(x, 16)


def group(input, size = 16):
    return [input[i * size: (i + 1) * size] for i in range(len(input) // size)]

def dec_hash(old_state_list):
    roundkey_list = [bytearray(b'r\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f'),
        bytearray(b'p\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f'),
        bytearray(b's\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f')
        ]

    total_state_list = []
    for old_state in old_state_list:
        new_state_list = []
        for roundkey in roundkey_list:
            state = int_to_bytes(old_state)
            temp = [0] * len(state)
            for i in range(len(state)):
                temp[i]  = state[p[i]]
            for i in range(len(state)):
                temp[i] = sbox.index(temp[i])
            new_state = repeated_xor(temp, roundkey)
            new_state_list.append(new_state[0])
        total_state_list.append(new_state_list)
    return total_state_list

def my_hand(total_state_list):
    s1, s2, s3 = map(lambda state: set(state), total_state_list)
    dup = s1 &amp; s2 &amp; s3
    dup = list(dup)[0]
    if total_state_list[0].index(dup) == 0:
        return b'p'
    elif total_state_list[0].index(dup) == 1:
        return b's'
    elif total_state_list[0].index(dup) == 2:
        return b'r'

io = remote('crypto1.ctf.nullcon.net', 5000)
recv_data = io.recv(1024)
for i in range(20):
    state_list = [recv_data.split(b' ')[-4], recv_data.split(b' ')[-3], recv_data.split(b' ')[-2][:-5]]
    # print(state_list)
    dec_list = dec_hash(list(map(lambda s: int(s, 16), state_list)))
    print(my_hand(dec_list))
    io.sendline(my_hand(dec_list))
    recv_data = io.recv(1024)
    print(recv_data)

io.interactive()
</code></pre><p>フラグゲット
<code>hackim20{b4d_pr1mitiv3_beats_all!1!_7f65}</code></p>
<h2 id="zelda1">Zelda1</h2>
<p>正式な問題名は忘れた。</p>
<p>Unity製のゼルダっぽいゲームが配布される</p>
<p>敵を倒すのが目的だが、敵に接触してもお互いノックバックするだけ</p>
<p>スペースキーで剣を振れるが、当てても接触したときと同じ</p>
<p><code>dnSpy</code>というソフトを使って解析する</p>
<p>Unity製のゲームはC#で書かれており、
そのソースコードは<code>Managed/Assembly-CSharp.dll</code>を解析することで確認できる。</p>
<p>敵を倒すアプローチは、こちらの攻撃力を上げる方法と敵のHPをゼロにする方法などが考えられるが、
今回は後者のチートを試みる。</p>
<p>敵のHPに関係しそうなメソッドを見てみる</p>
<p><code>Enemy</code>クラスに<code>TakeDamage</code>という関数がある</p>
<pre><code>private void TakeDamage(float damage)
{
	this.health -= damage;
	if (this.health &lt;= 0f)
	{
		base.StartCoroutine(this.ShowSome());
		base.gameObject.SetActive(false);
	}
}
</code></pre><p>どうやら<code>this.health &lt;= 0f</code>を<code>true</code>にすれば倒せそうだ</p>
<p>というわけで判定文を以下のようにいじる</p>
<pre><code>private void TakeDamage(float damage)
{
	this.health -= damage;
	if (this.health &lt;= 999999f)
	{
		base.StartCoroutine(this.ShowSome());
		base.gameObject.SetActive(false);
	}
}
</code></pre><p>ゲームを実行してみる</p>
<p>敵に接触した瞬間に敵が消え、画面上部にフラグが現れる</p>
<p><code>Flag: REVOLUTIONSTARTSWITHME</code></p>
<h2 id="zelda2">Zelda2</h2>
<p>先ほどと同じゲームにフラグが隠されている</p>
<p>今回は通常は入れない池の中に侵入するのが目的</p>
<p>また<code>dnSpy</code>というソフトを使って解析する</p>
<p>どこを変更すればいいか分からなかったので「Unity 障害物 すり抜け」などのキーワードでググる</p>
<p><a href="https://qiita.com/_tybt/items/0e9605b7acc955078c64">こんなページ</a>が見つかった</p>
<p>どうやら<code>Dynamic</code>ではなく<code>Kinematic</code>という設定にすれば良いらしい</p>
<p><code>kinematic</code>で検索すると<code>isKinematic</code>というメソッドが見つかる</p>
<p>(検索オプションの<code>Match Any Search Item</code>にチェックを入れること！)</p>
<pre><code>public bool isKinematic
		{
			get
			{
				return this.bodyType == RigidbodyType2D.Kinematic;
			}
			set
			{
				this.bodyType = ((!value) ? RigidbodyType2D.Dynamic : RigidbodyType2D.Kinematic);
			}
		}
</code></pre><p><code>Kinematic</code>にするかどうかを決めているらしい</p>
<p>常時<code>Kinematic</code>にするために、<code>set</code>を変更する</p>
<pre><code>public bool isKinematic
		{
			get
			{
				return this.bodyType == RigidbodyType2D.Kinematic;
			}
			set
			{
				this.bodyType = RigidbodyType2D.Kinematic;
			}
		}
</code></pre><p>ゲームを実行してみる</p>
<p>池に入ると、フラグが書かれたエリアにワープする</p>
<p><code>FLAG IS BENDTHERULES42PIRATE</code></p>
<h2 id="zelda3">Zelda3</h2>
<p>先ほどと同じゲームにフラグが隠されている</p>
<p>今回はゲームエリアの端っこに行くのが目的</p>
<p>また<code>dnSpy</code>というソフトを使って解析する</p>
<p>先ほどのチートで障害物をすり抜けることはできたので、今度は移動スピードを上げることを考える</p>
<p>移動スピードは以下のメソッドで計算される</p>
<pre><code>private void MoveCharacter()
{
	this.change.Normalize();
	this.myRigidbody.MovePosition(base.transform.position + this.change * this.speed * Time.deltaTime);
}
</code></pre><p><code>this.change * this.speed * Time.deltaTime</code>が移動量を表している（速さx時間）</p>
<p>ここで、以下のように変更してみる</p>
<pre><code>private void MoveCharacter()
{
	this.change.Normalize();
	this.myRigidbody.MovePosition(base.transform.position + this.change);
}
</code></pre><p>ゲームを実行してみる</p>
<p>某漫画にでてくる瞬歩みたいな挙動になる（おそらく<code>this.speed * Time.deltaTime</code>が１以下の小さな値になるため）</p>
<p>池があるエリアの右上からジャングルに入る</p>
<p>さらに右上に進むとフラグがある</p>
<p><code>EXPLORERFORLIFE</code></p>
<h2 id="感想">感想</h2>
<p>難しかったです。
ほぼ丸一日かけたのにあまり解けませんでした。
もっと精進します。</p>

			</div>
		</div>
	</div>
		<div class="links">
			<a href="https://kuzushiki.github.io/">Home</a>
			
				<a href="https://kuzushiki.github.io/post/">Archive</a>
			
			
				
			
				
					<a href="https://kuzushiki.github.io/pages/resume/">Résumé</a>
				
			
			<a href="#top">Top</a>
		</div>
		
		
		<p id="copyright">
			© Copyright 2020 kuzushiki
		</p>
		
	</body>
</html>

